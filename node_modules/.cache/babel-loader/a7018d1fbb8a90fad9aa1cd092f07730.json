{"ast":null,"code":"\"use strict\";\n\nconst $Ref = require(\"./ref\");\n\nconst Pointer = require(\"./pointer\");\n\nconst {\n  ono\n} = require(\"ono\");\n\nconst url = require(\"./util/url\");\n\nmodule.exports = dereference;\n/**\r\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\r\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\r\n *\r\n * @param {$RefParser} parser\r\n * @param {$RefParserOptions} options\r\n */\n\nfunction dereference(parser, options) {\n  // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\n  let dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", [], parser.$refs, options);\n  parser.$refs.circular = dereferenced.circular;\n  parser.schema = dereferenced.value;\n}\n/**\r\n * Recursively crawls the given value, and dereferences any JSON references.\r\n *\r\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\r\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\r\n * @param {string} pathFromRoot - The path of `obj` from the schema root\r\n * @param {object[]} parents - An array of the parent objects that have already been dereferenced\r\n * @param {$Refs} $refs\r\n * @param {$RefParserOptions} options\r\n * @returns {{value: object, circular: boolean}}\r\n */\n\n\nfunction crawl(obj, path, pathFromRoot, parents, $refs, options) {\n  let dereferenced;\n  let result = {\n    value: obj,\n    circular: false\n  };\n\n  if (obj && typeof obj === \"object\") {\n    parents.push(obj);\n\n    if ($Ref.isAllowed$Ref(obj, options)) {\n      dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, $refs, options);\n      result.circular = dereferenced.circular;\n      result.value = dereferenced.value;\n    } else {\n      for (let key of Object.keys(obj)) {\n        let keyPath = Pointer.join(path, key);\n        let keyPathFromRoot = Pointer.join(pathFromRoot, key);\n        let value = obj[key];\n        let circular = false;\n\n        if ($Ref.isAllowed$Ref(value, options)) {\n          dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, $refs, options);\n          circular = dereferenced.circular;\n          obj[key] = dereferenced.value;\n        } else {\n          if (parents.indexOf(value) === -1) {\n            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, $refs, options);\n            circular = dereferenced.circular;\n            obj[key] = dereferenced.value;\n          } else {\n            circular = foundCircularReference(keyPath, $refs, options);\n          }\n        } // Set the \"isCircular\" flag if this or any other property is circular\n\n\n        result.circular = result.circular || circular;\n      }\n    }\n\n    parents.pop();\n  }\n\n  return result;\n}\n/**\r\n * Dereferences the given JSON Reference, and then crawls the resulting value.\r\n *\r\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\r\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\r\n * @param {string} pathFromRoot - The path of `$ref` from the schema root\r\n * @param {object[]} parents - An array of the parent objects that have already been dereferenced\r\n * @param {$Refs} $refs\r\n * @param {$RefParserOptions} options\r\n * @returns {{value: object, circular: boolean}}\r\n */\n\n\nfunction dereference$Ref($ref, path, pathFromRoot, parents, $refs, options) {\n  // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\n  let $refPath = url.resolve(path, $ref.$ref);\n\n  let pointer = $refs._resolve($refPath, options); // Check for circular references\n\n\n  let directCircular = pointer.circular;\n  let circular = directCircular || parents.indexOf(pointer.value) !== -1;\n  circular && foundCircularReference(path, $refs, options); // Dereference the JSON reference\n\n  let dereferencedValue = $Ref.dereference($ref, pointer.value); // Crawl the dereferenced value (unless it's circular)\n\n  if (!circular) {\n    // Determine if the dereferenced value is circular\n    let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, $refs, options);\n    circular = dereferenced.circular;\n    dereferencedValue = dereferenced.value;\n  }\n\n  if (circular && !directCircular && options.dereference.circular === \"ignore\") {\n    // The user has chosen to \"ignore\" circular references, so don't change the value\n    dereferencedValue = $ref;\n  }\n\n  if (directCircular) {\n    // The pointer is a DIRECT circular reference (i.e. it references itself).\n    // So replace the $ref path with the absolute path from the JSON Schema root\n    dereferencedValue.$ref = pathFromRoot;\n  }\n\n  return {\n    circular,\n    value: dereferencedValue\n  };\n}\n/**\r\n * Called when a circular reference is found.\r\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\r\n *\r\n * @param {string} keyPath - The JSON Reference path of the circular reference\r\n * @param {$Refs} $refs\r\n * @param {$RefParserOptions} options\r\n * @returns {boolean} - always returns true, to indicate that a circular reference was found\r\n */\n\n\nfunction foundCircularReference(keyPath, $refs, options) {\n  $refs.circular = true;\n\n  if (!options.dereference.circular) {\n    throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\n  }\n\n  return true;\n}","map":{"version":3,"sources":["/Users/katrinaliu/my-jsonforms-app/node_modules/json-schema-ref-parser/lib/dereference.js"],"names":["$Ref","require","Pointer","ono","url","module","exports","dereference","parser","options","dereferenced","crawl","schema","$refs","_root$Ref","path","circular","value","obj","pathFromRoot","parents","result","push","isAllowed$Ref","dereference$Ref","key","Object","keys","keyPath","join","keyPathFromRoot","indexOf","foundCircularReference","pop","$ref","$refPath","resolve","pointer","_resolve","directCircular","dereferencedValue","reference"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nconst $Ref = require(\"./ref\");\r\nconst Pointer = require(\"./pointer\");\r\nconst { ono } = require(\"ono\");\r\nconst url = require(\"./util/url\");\r\n\r\nmodule.exports = dereference;\r\n\r\n/**\r\n * Crawls the JSON schema, finds all JSON references, and dereferences them.\r\n * This method mutates the JSON schema object, replacing JSON references with their resolved value.\r\n *\r\n * @param {$RefParser} parser\r\n * @param {$RefParserOptions} options\r\n */\r\nfunction dereference (parser, options) {\r\n  // console.log('Dereferencing $ref pointers in %s', parser.$refs._root$Ref.path);\r\n  let dereferenced = crawl(parser.schema, parser.$refs._root$Ref.path, \"#\", [], parser.$refs, options);\r\n  parser.$refs.circular = dereferenced.circular;\r\n  parser.schema = dereferenced.value;\r\n}\r\n\r\n/**\r\n * Recursively crawls the given value, and dereferences any JSON references.\r\n *\r\n * @param {*} obj - The value to crawl. If it's not an object or array, it will be ignored.\r\n * @param {string} path - The full path of `obj`, possibly with a JSON Pointer in the hash\r\n * @param {string} pathFromRoot - The path of `obj` from the schema root\r\n * @param {object[]} parents - An array of the parent objects that have already been dereferenced\r\n * @param {$Refs} $refs\r\n * @param {$RefParserOptions} options\r\n * @returns {{value: object, circular: boolean}}\r\n */\r\nfunction crawl (obj, path, pathFromRoot, parents, $refs, options) {\r\n  let dereferenced;\r\n  let result = {\r\n    value: obj,\r\n    circular: false\r\n  };\r\n\r\n  if (obj && typeof obj === \"object\") {\r\n    parents.push(obj);\r\n\r\n    if ($Ref.isAllowed$Ref(obj, options)) {\r\n      dereferenced = dereference$Ref(obj, path, pathFromRoot, parents, $refs, options);\r\n      result.circular = dereferenced.circular;\r\n      result.value = dereferenced.value;\r\n    }\r\n    else {\r\n      for (let key of Object.keys(obj)) {\r\n        let keyPath = Pointer.join(path, key);\r\n        let keyPathFromRoot = Pointer.join(pathFromRoot, key);\r\n        let value = obj[key];\r\n        let circular = false;\r\n\r\n        if ($Ref.isAllowed$Ref(value, options)) {\r\n          dereferenced = dereference$Ref(value, keyPath, keyPathFromRoot, parents, $refs, options);\r\n          circular = dereferenced.circular;\r\n          obj[key] = dereferenced.value;\r\n        }\r\n        else {\r\n          if (parents.indexOf(value) === -1) {\r\n            dereferenced = crawl(value, keyPath, keyPathFromRoot, parents, $refs, options);\r\n            circular = dereferenced.circular;\r\n            obj[key] = dereferenced.value;\r\n          }\r\n          else {\r\n            circular = foundCircularReference(keyPath, $refs, options);\r\n          }\r\n        }\r\n\r\n        // Set the \"isCircular\" flag if this or any other property is circular\r\n        result.circular = result.circular || circular;\r\n      }\r\n    }\r\n\r\n    parents.pop();\r\n  }\r\n\r\n  return result;\r\n}\r\n\r\n/**\r\n * Dereferences the given JSON Reference, and then crawls the resulting value.\r\n *\r\n * @param {{$ref: string}} $ref - The JSON Reference to resolve\r\n * @param {string} path - The full path of `$ref`, possibly with a JSON Pointer in the hash\r\n * @param {string} pathFromRoot - The path of `$ref` from the schema root\r\n * @param {object[]} parents - An array of the parent objects that have already been dereferenced\r\n * @param {$Refs} $refs\r\n * @param {$RefParserOptions} options\r\n * @returns {{value: object, circular: boolean}}\r\n */\r\nfunction dereference$Ref ($ref, path, pathFromRoot, parents, $refs, options) {\r\n  // console.log('Dereferencing $ref pointer \"%s\" at %s', $ref.$ref, path);\r\n\r\n  let $refPath = url.resolve(path, $ref.$ref);\r\n  let pointer = $refs._resolve($refPath, options);\r\n\r\n  // Check for circular references\r\n  let directCircular = pointer.circular;\r\n  let circular = directCircular || parents.indexOf(pointer.value) !== -1;\r\n  circular && foundCircularReference(path, $refs, options);\r\n\r\n  // Dereference the JSON reference\r\n  let dereferencedValue = $Ref.dereference($ref, pointer.value);\r\n\r\n  // Crawl the dereferenced value (unless it's circular)\r\n  if (!circular) {\r\n    // Determine if the dereferenced value is circular\r\n    let dereferenced = crawl(dereferencedValue, pointer.path, pathFromRoot, parents, $refs, options);\r\n    circular = dereferenced.circular;\r\n    dereferencedValue = dereferenced.value;\r\n  }\r\n\r\n  if (circular && !directCircular && options.dereference.circular === \"ignore\") {\r\n    // The user has chosen to \"ignore\" circular references, so don't change the value\r\n    dereferencedValue = $ref;\r\n  }\r\n\r\n  if (directCircular) {\r\n    // The pointer is a DIRECT circular reference (i.e. it references itself).\r\n    // So replace the $ref path with the absolute path from the JSON Schema root\r\n    dereferencedValue.$ref = pathFromRoot;\r\n  }\r\n\r\n  return {\r\n    circular,\r\n    value: dereferencedValue\r\n  };\r\n}\r\n\r\n/**\r\n * Called when a circular reference is found.\r\n * It sets the {@link $Refs#circular} flag, and throws an error if options.dereference.circular is false.\r\n *\r\n * @param {string} keyPath - The JSON Reference path of the circular reference\r\n * @param {$Refs} $refs\r\n * @param {$RefParserOptions} options\r\n * @returns {boolean} - always returns true, to indicate that a circular reference was found\r\n */\r\nfunction foundCircularReference (keyPath, $refs, options) {\r\n  $refs.circular = true;\r\n  if (!options.dereference.circular) {\r\n    throw ono.reference(`Circular $ref pointer found at ${keyPath}`);\r\n  }\r\n  return true;\r\n}\r\n"]},"metadata":{},"sourceType":"script"}