{"ast":null,"code":"\"use strict\";\n\nlet isWindows = /^win/.test(process.platform),\n    forwardSlashPattern = /\\//g,\n    protocolPattern = /^(\\w{2,}):\\/\\//i,\n    url = module.exports; // RegExp patterns to URL-encode special characters in local filesystem paths\n\nlet urlEncodePatterns = [/\\?/g, \"%3F\", /\\#/g, \"%23\"]; // RegExp patterns to URL-decode special characters for local filesystem paths\n\nlet urlDecodePatterns = [/\\%23/g, \"#\", /\\%24/g, \"$\", /\\%26/g, \"&\", /\\%2C/g, \",\", /\\%40/g, \"@\"];\nexports.parse = require(\"url\").parse;\nexports.resolve = require(\"url\").resolve;\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns {string}\n */\n\nexports.cwd = function cwd() {\n  return process.browser ? location.href : process.cwd() + \"/\";\n};\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param   {string} path\n * @returns {?string}\n */\n\n\nexports.getProtocol = function getProtocol(path) {\n  let match = protocolPattern.exec(path);\n\n  if (match) {\n    return match[1].toLowerCase();\n  }\n};\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param   {string} path\n * @returns {string}\n */\n\n\nexports.getExtension = function getExtension(path) {\n  let lastDot = path.lastIndexOf(\".\");\n\n  if (lastDot >= 0) {\n    return path.substr(lastDot).toLowerCase();\n  }\n\n  return \"\";\n};\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param   {string} path\n * @returns {string}\n */\n\n\nexports.getHash = function getHash(path) {\n  let hashIndex = path.indexOf(\"#\");\n\n  if (hashIndex >= 0) {\n    return path.substr(hashIndex);\n  }\n\n  return \"#\";\n};\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\n\n\nexports.stripHash = function stripHash(path) {\n  let hashIndex = path.indexOf(\"#\");\n\n  if (hashIndex >= 0) {\n    path = path.substr(0, hashIndex);\n  }\n\n  return path;\n};\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param   {string} path\n * @returns {boolean}\n */\n\n\nexports.isHttp = function isHttp(path) {\n  let protocol = url.getProtocol(path);\n\n  if (protocol === \"http\" || protocol === \"https\") {\n    return true;\n  } else if (protocol === undefined) {\n    // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n    return process.browser;\n  } else {\n    // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n    return false;\n  }\n};\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param   {string} path\n * @returns {boolean}\n */\n\n\nexports.isFileSystemPath = function isFileSystemPath(path) {\n  if (process.browser) {\n    // We're running in a browser, so assume that all paths are URLs.\n    // This way, even relative paths will be treated as URLs rather than as filesystem paths\n    return false;\n  }\n\n  let protocol = url.getProtocol(path);\n  return protocol === undefined || protocol === \"file\";\n};\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param {string} path\n * @returns {string}\n */\n\n\nexports.fromFileSystemPath = function fromFileSystemPath(path) {\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows) {\n    path = path.replace(/\\\\/g, \"/\");\n  } // Step 2: `encodeURI` will take care of MOST characters\n\n\n  path = encodeURI(path); // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n\n  return path;\n};\n/**\n * Converts a URL to a local filesystem path.\n *\n * @param {string}  path\n * @param {boolean} [keepFileProtocol] - If true, then \"file://\" will NOT be stripped\n * @returns {string}\n */\n\n\nexports.toFileSystemPath = function toFileSystemPath(path, keepFileProtocol) {\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  path = decodeURI(path); // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  } // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n\n\n  let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === \"/\" ? path.substr(8) : path.substr(7); // insert a colon (\":\") after the drive letter on Windows\n\n    if (isWindows && path[1] === \"/\") {\n      path = path[0] + \":\" + path.substr(1);\n    }\n\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = \"file:///\" + path;\n    } else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindows ? path : \"/\" + path;\n    }\n  } // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n\n\n  if (isWindows && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = path.replace(forwardSlashPattern, \"\\\\\"); // Capitalize the drive letter\n\n    if (path.substr(1, 2) === \":\\\\\") {\n      path = path[0].toUpperCase() + path.substr(1);\n    }\n  }\n\n  return path;\n};","map":{"version":3,"sources":["/Users/katrinaliu/my-jsonforms-app/node_modules/json-schema-ref-parser/lib/util/url.js"],"names":["isWindows","test","process","platform","forwardSlashPattern","protocolPattern","url","module","exports","urlEncodePatterns","urlDecodePatterns","parse","require","resolve","cwd","browser","location","href","getProtocol","path","match","exec","toLowerCase","getExtension","lastDot","lastIndexOf","substr","getHash","hashIndex","indexOf","stripHash","isHttp","protocol","undefined","isFileSystemPath","fromFileSystemPath","replace","encodeURI","i","length","toFileSystemPath","keepFileProtocol","decodeURI","isFileUrl","toUpperCase"],"mappings":"AAAA;;AAEA,IAAIA,SAAS,GAAG,OAAOC,IAAP,CAAYC,OAAO,CAACC,QAApB,CAAhB;AAAA,IACIC,mBAAmB,GAAG,KAD1B;AAAA,IAEIC,eAAe,GAAG,iBAFtB;AAAA,IAGIC,GAAG,GAAGC,MAAM,CAACC,OAHjB,C,CAKA;;AACA,IAAIC,iBAAiB,GAAG,CACtB,KADsB,EACf,KADe,EAEtB,KAFsB,EAEf,KAFe,CAAxB,C,CAKA;;AACA,IAAIC,iBAAiB,GAAG,CACtB,OADsB,EACb,GADa,EAEtB,OAFsB,EAEb,GAFa,EAGtB,OAHsB,EAGb,GAHa,EAItB,OAJsB,EAIb,GAJa,EAKtB,OALsB,EAKb,GALa,CAAxB;AAQAF,OAAO,CAACG,KAAR,GAAgBC,OAAO,CAAC,KAAD,CAAP,CAAeD,KAA/B;AACAH,OAAO,CAACK,OAAR,GAAkBD,OAAO,CAAC,KAAD,CAAP,CAAeC,OAAjC;AAEA;AACA;AACA;AACA;AACA;;AACAL,OAAO,CAACM,GAAR,GAAc,SAASA,GAAT,GAAgB;AAC5B,SAAOZ,OAAO,CAACa,OAAR,GAAkBC,QAAQ,CAACC,IAA3B,GAAkCf,OAAO,CAACY,GAAR,KAAgB,GAAzD;AACD,CAFD;AAIA;AACA;AACA;AACA;AACA;AACA;;;AACAN,OAAO,CAACU,WAAR,GAAsB,SAASA,WAAT,CAAsBC,IAAtB,EAA4B;AAChD,MAAIC,KAAK,GAAGf,eAAe,CAACgB,IAAhB,CAAqBF,IAArB,CAAZ;;AACA,MAAIC,KAAJ,EAAW;AACT,WAAOA,KAAK,CAAC,CAAD,CAAL,CAASE,WAAT,EAAP;AACD;AACF,CALD;AAOA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAd,OAAO,CAACe,YAAR,GAAuB,SAASA,YAAT,CAAuBJ,IAAvB,EAA6B;AAClD,MAAIK,OAAO,GAAGL,IAAI,CAACM,WAAL,CAAiB,GAAjB,CAAd;;AACA,MAAID,OAAO,IAAI,CAAf,EAAkB;AAChB,WAAOL,IAAI,CAACO,MAAL,CAAYF,OAAZ,EAAqBF,WAArB,EAAP;AACD;;AACD,SAAO,EAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAd,OAAO,CAACmB,OAAR,GAAkB,SAASA,OAAT,CAAkBR,IAAlB,EAAwB;AACxC,MAAIS,SAAS,GAAGT,IAAI,CAACU,OAAL,CAAa,GAAb,CAAhB;;AACA,MAAID,SAAS,IAAI,CAAjB,EAAoB;AAClB,WAAOT,IAAI,CAACO,MAAL,CAAYE,SAAZ,CAAP;AACD;;AACD,SAAO,GAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACApB,OAAO,CAACsB,SAAR,GAAoB,SAASA,SAAT,CAAoBX,IAApB,EAA0B;AAC5C,MAAIS,SAAS,GAAGT,IAAI,CAACU,OAAL,CAAa,GAAb,CAAhB;;AACA,MAAID,SAAS,IAAI,CAAjB,EAAoB;AAClBT,IAAAA,IAAI,GAAGA,IAAI,CAACO,MAAL,CAAY,CAAZ,EAAeE,SAAf,CAAP;AACD;;AACD,SAAOT,IAAP;AACD,CAND;AAQA;AACA;AACA;AACA;AACA;AACA;;;AACAX,OAAO,CAACuB,MAAR,GAAiB,SAASA,MAAT,CAAiBZ,IAAjB,EAAuB;AACtC,MAAIa,QAAQ,GAAG1B,GAAG,CAACY,WAAJ,CAAgBC,IAAhB,CAAf;;AACA,MAAIa,QAAQ,KAAK,MAAb,IAAuBA,QAAQ,KAAK,OAAxC,EAAiD;AAC/C,WAAO,IAAP;AACD,GAFD,MAGK,IAAIA,QAAQ,KAAKC,SAAjB,EAA4B;AAC/B;AACA,WAAO/B,OAAO,CAACa,OAAf;AACD,GAHI,MAIA;AACH;AACA,WAAO,KAAP;AACD;AACF,CAbD;AAeA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAP,OAAO,CAAC0B,gBAAR,GAA2B,SAASA,gBAAT,CAA2Bf,IAA3B,EAAiC;AAC1D,MAAIjB,OAAO,CAACa,OAAZ,EAAqB;AACnB;AACA;AACA,WAAO,KAAP;AACD;;AAED,MAAIiB,QAAQ,GAAG1B,GAAG,CAACY,WAAJ,CAAgBC,IAAhB,CAAf;AACA,SAAOa,QAAQ,KAAKC,SAAb,IAA0BD,QAAQ,KAAK,MAA9C;AACD,CATD;AAWA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAxB,OAAO,CAAC2B,kBAAR,GAA6B,SAASA,kBAAT,CAA6BhB,IAA7B,EAAmC;AAC9D;AACA;AACA,MAAInB,SAAJ,EAAe;AACbmB,IAAAA,IAAI,GAAGA,IAAI,CAACiB,OAAL,CAAa,KAAb,EAAoB,GAApB,CAAP;AACD,GAL6D,CAO9D;;;AACAjB,EAAAA,IAAI,GAAGkB,SAAS,CAAClB,IAAD,CAAhB,CAR8D,CAU9D;AACA;AACA;;AACA,OAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG7B,iBAAiB,CAAC8B,MAAtC,EAA8CD,CAAC,IAAI,CAAnD,EAAsD;AACpDnB,IAAAA,IAAI,GAAGA,IAAI,CAACiB,OAAL,CAAa3B,iBAAiB,CAAC6B,CAAD,CAA9B,EAAmC7B,iBAAiB,CAAC6B,CAAC,GAAG,CAAL,CAApD,CAAP;AACD;;AAED,SAAOnB,IAAP;AACD,CAlBD;AAoBA;AACA;AACA;AACA;AACA;AACA;AACA;;;AACAX,OAAO,CAACgC,gBAAR,GAA2B,SAASA,gBAAT,CAA2BrB,IAA3B,EAAiCsB,gBAAjC,EAAmD;AAC5E;AACAtB,EAAAA,IAAI,GAAGuB,SAAS,CAACvB,IAAD,CAAhB,CAF4E,CAI5E;AACA;AACA;;AACA,OAAK,IAAImB,CAAC,GAAG,CAAb,EAAgBA,CAAC,GAAG5B,iBAAiB,CAAC6B,MAAtC,EAA8CD,CAAC,IAAI,CAAnD,EAAsD;AACpDnB,IAAAA,IAAI,GAAGA,IAAI,CAACiB,OAAL,CAAa1B,iBAAiB,CAAC4B,CAAD,CAA9B,EAAmC5B,iBAAiB,CAAC4B,CAAC,GAAG,CAAL,CAApD,CAAP;AACD,GAT2E,CAW5E;AACA;;;AACA,MAAIK,SAAS,GAAGxB,IAAI,CAACO,MAAL,CAAY,CAAZ,EAAe,CAAf,EAAkBJ,WAAlB,OAAoC,SAApD;;AACA,MAAIqB,SAAJ,EAAe;AACb;AACAxB,IAAAA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAJ,KAAY,GAAZ,GAAkBA,IAAI,CAACO,MAAL,CAAY,CAAZ,CAAlB,GAAmCP,IAAI,CAACO,MAAL,CAAY,CAAZ,CAA1C,CAFa,CAIb;;AACA,QAAI1B,SAAS,IAAImB,IAAI,CAAC,CAAD,CAAJ,KAAY,GAA7B,EAAkC;AAChCA,MAAAA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAJ,GAAU,GAAV,GAAgBA,IAAI,CAACO,MAAL,CAAY,CAAZ,CAAvB;AACD;;AAED,QAAIe,gBAAJ,EAAsB;AACpB;AACAtB,MAAAA,IAAI,GAAG,aAAaA,IAApB;AACD,KAHD,MAIK;AACH;AACA;AACA;AACAwB,MAAAA,SAAS,GAAG,KAAZ;AACAxB,MAAAA,IAAI,GAAGnB,SAAS,GAAGmB,IAAH,GAAU,MAAMA,IAAhC;AACD;AACF,GAlC2E,CAoC5E;;;AACA,MAAInB,SAAS,IAAI,CAAC2C,SAAlB,EAA6B;AAC3B;AACAxB,IAAAA,IAAI,GAAGA,IAAI,CAACiB,OAAL,CAAahC,mBAAb,EAAkC,IAAlC,CAAP,CAF2B,CAI3B;;AACA,QAAIe,IAAI,CAACO,MAAL,CAAY,CAAZ,EAAe,CAAf,MAAsB,KAA1B,EAAiC;AAC/BP,MAAAA,IAAI,GAAGA,IAAI,CAAC,CAAD,CAAJ,CAAQyB,WAAR,KAAwBzB,IAAI,CAACO,MAAL,CAAY,CAAZ,CAA/B;AACD;AACF;;AAED,SAAOP,IAAP;AACD,CAhDD","sourcesContent":["\"use strict\";\n\nlet isWindows = /^win/.test(process.platform),\n    forwardSlashPattern = /\\//g,\n    protocolPattern = /^(\\w{2,}):\\/\\//i,\n    url = module.exports;\n\n// RegExp patterns to URL-encode special characters in local filesystem paths\nlet urlEncodePatterns = [\n  /\\?/g, \"%3F\",\n  /\\#/g, \"%23\",\n];\n\n// RegExp patterns to URL-decode special characters for local filesystem paths\nlet urlDecodePatterns = [\n  /\\%23/g, \"#\",\n  /\\%24/g, \"$\",\n  /\\%26/g, \"&\",\n  /\\%2C/g, \",\",\n  /\\%40/g, \"@\"\n];\n\nexports.parse = require(\"url\").parse;\nexports.resolve = require(\"url\").resolve;\n\n/**\n * Returns the current working directory (in Node) or the current page URL (in browsers).\n *\n * @returns {string}\n */\nexports.cwd = function cwd () {\n  return process.browser ? location.href : process.cwd() + \"/\";\n};\n\n/**\n * Returns the protocol of the given URL, or `undefined` if it has no protocol.\n *\n * @param   {string} path\n * @returns {?string}\n */\nexports.getProtocol = function getProtocol (path) {\n  let match = protocolPattern.exec(path);\n  if (match) {\n    return match[1].toLowerCase();\n  }\n};\n\n/**\n * Returns the lowercased file extension of the given URL,\n * or an empty string if it has no extension.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getExtension = function getExtension (path) {\n  let lastDot = path.lastIndexOf(\".\");\n  if (lastDot >= 0) {\n    return path.substr(lastDot).toLowerCase();\n  }\n  return \"\";\n};\n\n/**\n * Returns the hash (URL fragment), of the given path.\n * If there is no hash, then the root hash (\"#\") is returned.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.getHash = function getHash (path) {\n  let hashIndex = path.indexOf(\"#\");\n  if (hashIndex >= 0) {\n    return path.substr(hashIndex);\n  }\n  return \"#\";\n};\n\n/**\n * Removes the hash (URL fragment), if any, from the given path.\n *\n * @param   {string} path\n * @returns {string}\n */\nexports.stripHash = function stripHash (path) {\n  let hashIndex = path.indexOf(\"#\");\n  if (hashIndex >= 0) {\n    path = path.substr(0, hashIndex);\n  }\n  return path;\n};\n\n/**\n * Determines whether the given path is an HTTP(S) URL.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isHttp = function isHttp (path) {\n  let protocol = url.getProtocol(path);\n  if (protocol === \"http\" || protocol === \"https\") {\n    return true;\n  }\n  else if (protocol === undefined) {\n    // There is no protocol.  If we're running in a browser, then assume it's HTTP.\n    return process.browser;\n  }\n  else {\n    // It's some other protocol, such as \"ftp://\", \"mongodb://\", etc.\n    return false;\n  }\n};\n\n/**\n * Determines whether the given path is a filesystem path.\n * This includes \"file://\" URLs.\n *\n * @param   {string} path\n * @returns {boolean}\n */\nexports.isFileSystemPath = function isFileSystemPath (path) {\n  if (process.browser) {\n    // We're running in a browser, so assume that all paths are URLs.\n    // This way, even relative paths will be treated as URLs rather than as filesystem paths\n    return false;\n  }\n\n  let protocol = url.getProtocol(path);\n  return protocol === undefined || protocol === \"file\";\n};\n\n/**\n * Converts a filesystem path to a properly-encoded URL.\n *\n * This is intended to handle situations where JSON Schema $Ref Parser is called\n * with a filesystem path that contains characters which are not allowed in URLs.\n *\n * @example\n * The following filesystem paths would be converted to the following URLs:\n *\n *    <\"!@#$%^&*+=?'>.json              ==>   %3C%22!@%23$%25%5E&*+=%3F\\'%3E.json\n *    C:\\\\My Documents\\\\File (1).json   ==>   C:/My%20Documents/File%20(1).json\n *    file://Project #42/file.json      ==>   file://Project%20%2342/file.json\n *\n * @param {string} path\n * @returns {string}\n */\nexports.fromFileSystemPath = function fromFileSystemPath (path) {\n  // Step 1: On Windows, replace backslashes with forward slashes,\n  // rather than encoding them as \"%5C\"\n  if (isWindows) {\n    path = path.replace(/\\\\/g, \"/\");\n  }\n\n  // Step 2: `encodeURI` will take care of MOST characters\n  path = encodeURI(path);\n\n  // Step 3: Manually encode characters that are not encoded by `encodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlEncodePatterns.length; i += 2) {\n    path = path.replace(urlEncodePatterns[i], urlEncodePatterns[i + 1]);\n  }\n\n  return path;\n};\n\n/**\n * Converts a URL to a local filesystem path.\n *\n * @param {string}  path\n * @param {boolean} [keepFileProtocol] - If true, then \"file://\" will NOT be stripped\n * @returns {string}\n */\nexports.toFileSystemPath = function toFileSystemPath (path, keepFileProtocol) {\n  // Step 1: `decodeURI` will decode characters such as Cyrillic characters, spaces, etc.\n  path = decodeURI(path);\n\n  // Step 2: Manually decode characters that are not decoded by `decodeURI`.\n  // This includes characters such as \"#\" and \"?\", which have special meaning in URLs,\n  // but are just normal characters in a filesystem path.\n  for (let i = 0; i < urlDecodePatterns.length; i += 2) {\n    path = path.replace(urlDecodePatterns[i], urlDecodePatterns[i + 1]);\n  }\n\n  // Step 3: If it's a \"file://\" URL, then format it consistently\n  // or convert it to a local filesystem path\n  let isFileUrl = path.substr(0, 7).toLowerCase() === \"file://\";\n  if (isFileUrl) {\n    // Strip-off the protocol, and the initial \"/\", if there is one\n    path = path[7] === \"/\" ? path.substr(8) : path.substr(7);\n\n    // insert a colon (\":\") after the drive letter on Windows\n    if (isWindows && path[1] === \"/\") {\n      path = path[0] + \":\" + path.substr(1);\n    }\n\n    if (keepFileProtocol) {\n      // Return the consistently-formatted \"file://\" URL\n      path = \"file:///\" + path;\n    }\n    else {\n      // Convert the \"file://\" URL to a local filesystem path.\n      // On Windows, it will start with something like \"C:/\".\n      // On Posix, it will start with \"/\"\n      isFileUrl = false;\n      path = isWindows ? path : \"/\" + path;\n    }\n  }\n\n  // Step 4: Normalize Windows paths (unless it's a \"file://\" URL)\n  if (isWindows && !isFileUrl) {\n    // Replace forward slashes with backslashes\n    path = path.replace(forwardSlashPattern, \"\\\\\");\n\n    // Capitalize the drive letter\n    if (path.substr(1, 2) === \":\\\\\") {\n      path = path[0].toUpperCase() + path.substr(1);\n    }\n  }\n\n  return path;\n};\n"]},"metadata":{},"sourceType":"script"}