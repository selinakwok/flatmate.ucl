{"ast":null,"code":"\"use strict\";\n\nconst {\n  ono\n} = require(\"ono\");\n\nconst $Ref = require(\"./ref\");\n\nconst url = require(\"./util/url\");\n\nmodule.exports = $Refs;\n/**\r\n * This class is a map of JSON references and their resolved values.\r\n */\n\nfunction $Refs() {\n  /**\r\n   * Indicates whether the schema contains any circular references.\r\n   *\r\n   * @type {boolean}\r\n   */\n  this.circular = false;\n  /**\r\n   * A map of paths/urls to {@link $Ref} objects\r\n   *\r\n   * @type {object}\r\n   * @protected\r\n   */\n\n  this._$refs = {};\n  /**\r\n   * The {@link $Ref} object that is the root of the JSON schema.\r\n   *\r\n   * @type {$Ref}\r\n   * @protected\r\n   */\n\n  this._root$Ref = null;\n}\n/**\r\n * Returns the paths of all the files/URLs that are referenced by the JSON schema,\r\n * including the schema itself.\r\n *\r\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\r\n * @returns {string[]}\r\n */\n\n\n$Refs.prototype.paths = function (types) {\n  let paths = getPaths(this._$refs, arguments);\n  return paths.map(path => {\n    return path.decoded;\n  });\n};\n/**\r\n * Returns the map of JSON references and their resolved values.\r\n *\r\n * @param {...string|string[]} [types] - Only return references of the given types (\"file\", \"http\", etc.)\r\n * @returns {object}\r\n */\n\n\n$Refs.prototype.values = function (types) {\n  let $refs = this._$refs;\n  let paths = getPaths($refs, arguments);\n  return paths.reduce((obj, path) => {\n    obj[path.decoded] = $refs[path.encoded].value;\n    return obj;\n  }, {});\n};\n/**\r\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\r\n *\r\n * @returns {object}\r\n */\n\n\n$Refs.prototype.toJSON = $Refs.prototype.values;\n/**\r\n * Determines whether the given JSON reference exists.\r\n *\r\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\r\n * @param {$RefParserOptions} [options]\r\n * @returns {boolean}\r\n */\n\n$Refs.prototype.exists = function (path, options) {\n  try {\n    this._resolve(path, options);\n\n    return true;\n  } catch (e) {\n    return false;\n  }\n};\n/**\r\n * Resolves the given JSON reference and returns the resolved value.\r\n *\r\n * @param {string} path - The path being resolved, with a JSON pointer in the hash\r\n * @param {$RefParserOptions} [options]\r\n * @returns {*} - Returns the resolved value\r\n */\n\n\n$Refs.prototype.get = function (path, options) {\n  return this._resolve(path, options).value;\n};\n/**\r\n * Sets the value of a nested property within this {@link $Ref#value}.\r\n * If the property, or any of its parents don't exist, they will be created.\r\n *\r\n * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash\r\n * @param {*} value - The value to assign\r\n */\n\n\n$Refs.prototype.set = function (path, value) {\n  let absPath = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(absPath);\n  let $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  $ref.set(absPath, value);\n};\n/**\r\n * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\r\n *\r\n * @param {string} path  - The file path or URL of the referenced file\r\n */\n\n\n$Refs.prototype._add = function (path) {\n  let withoutHash = url.stripHash(path);\n  let $ref = new $Ref();\n  $ref.path = withoutHash;\n  $ref.$refs = this;\n  this._$refs[withoutHash] = $ref;\n  this._root$Ref = this._root$Ref || $ref;\n  return $ref;\n};\n/**\r\n * Resolves the given JSON reference.\r\n *\r\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\r\n * @param {$RefParserOptions} [options]\r\n * @returns {Pointer}\r\n * @protected\r\n */\n\n\n$Refs.prototype._resolve = function (path, options) {\n  let absPath = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(absPath);\n  let $ref = this._$refs[withoutHash];\n\n  if (!$ref) {\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\n  }\n\n  return $ref.resolve(absPath, options, path);\n};\n/**\r\n * Returns the specified {@link $Ref} object, or undefined.\r\n *\r\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\r\n * @returns {$Ref|undefined}\r\n * @protected\r\n */\n\n\n$Refs.prototype._get$Ref = function (path) {\n  path = url.resolve(this._root$Ref.path, path);\n  let withoutHash = url.stripHash(path);\n  return this._$refs[withoutHash];\n};\n/**\r\n * Returns the encoded and decoded paths keys of the given object.\r\n *\r\n * @param {object} $refs - The object whose keys are URL-encoded paths\r\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\r\n * @returns {object[]}\r\n */\n\n\nfunction getPaths($refs, types) {\n  let paths = Object.keys($refs); // Filter the paths by type\n\n  types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\n\n  if (types.length > 0 && types[0]) {\n    paths = paths.filter(key => {\n      return types.indexOf($refs[key].pathType) !== -1;\n    });\n  } // Decode local filesystem paths\n\n\n  return paths.map(path => {\n    return {\n      encoded: path,\n      decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path\n    };\n  });\n}","map":{"version":3,"sources":["/Users/katrinaliu/my-jsonforms-app/node_modules/json-schema-ref-parser/lib/refs.js"],"names":["ono","require","$Ref","url","module","exports","$Refs","circular","_$refs","_root$Ref","prototype","paths","types","getPaths","arguments","map","path","decoded","values","$refs","reduce","obj","encoded","value","toJSON","exists","options","_resolve","e","get","set","absPath","resolve","withoutHash","stripHash","$ref","_add","_get$Ref","Object","keys","Array","isArray","slice","call","length","filter","key","indexOf","pathType","toFileSystemPath"],"mappings":"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","sourcesContent":["\"use strict\";\r\n\r\nconst { ono } = require(\"ono\");\r\nconst $Ref = require(\"./ref\");\r\nconst url = require(\"./util/url\");\r\n\r\nmodule.exports = $Refs;\r\n\r\n/**\r\n * This class is a map of JSON references and their resolved values.\r\n */\r\nfunction $Refs () {\r\n  /**\r\n   * Indicates whether the schema contains any circular references.\r\n   *\r\n   * @type {boolean}\r\n   */\r\n  this.circular = false;\r\n\r\n  /**\r\n   * A map of paths/urls to {@link $Ref} objects\r\n   *\r\n   * @type {object}\r\n   * @protected\r\n   */\r\n  this._$refs = {};\r\n\r\n  /**\r\n   * The {@link $Ref} object that is the root of the JSON schema.\r\n   *\r\n   * @type {$Ref}\r\n   * @protected\r\n   */\r\n  this._root$Ref = null;\r\n}\r\n\r\n/**\r\n * Returns the paths of all the files/URLs that are referenced by the JSON schema,\r\n * including the schema itself.\r\n *\r\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\r\n * @returns {string[]}\r\n */\r\n$Refs.prototype.paths = function (types) {\r\n  let paths = getPaths(this._$refs, arguments);\r\n  return paths.map((path) => {\r\n    return path.decoded;\r\n  });\r\n};\r\n\r\n/**\r\n * Returns the map of JSON references and their resolved values.\r\n *\r\n * @param {...string|string[]} [types] - Only return references of the given types (\"file\", \"http\", etc.)\r\n * @returns {object}\r\n */\r\n$Refs.prototype.values = function (types) {\r\n  let $refs = this._$refs;\r\n  let paths = getPaths($refs, arguments);\r\n  return paths.reduce((obj, path) => {\r\n    obj[path.decoded] = $refs[path.encoded].value;\r\n    return obj;\r\n  }, {});\r\n};\r\n\r\n/**\r\n * Returns a POJO (plain old JavaScript object) for serialization as JSON.\r\n *\r\n * @returns {object}\r\n */\r\n$Refs.prototype.toJSON = $Refs.prototype.values;\r\n\r\n/**\r\n * Determines whether the given JSON reference exists.\r\n *\r\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\r\n * @param {$RefParserOptions} [options]\r\n * @returns {boolean}\r\n */\r\n$Refs.prototype.exists = function (path, options) {\r\n  try {\r\n    this._resolve(path, options);\r\n    return true;\r\n  }\r\n  catch (e) {\r\n    return false;\r\n  }\r\n};\r\n\r\n/**\r\n * Resolves the given JSON reference and returns the resolved value.\r\n *\r\n * @param {string} path - The path being resolved, with a JSON pointer in the hash\r\n * @param {$RefParserOptions} [options]\r\n * @returns {*} - Returns the resolved value\r\n */\r\n$Refs.prototype.get = function (path, options) {\r\n  return this._resolve(path, options).value;\r\n};\r\n\r\n/**\r\n * Sets the value of a nested property within this {@link $Ref#value}.\r\n * If the property, or any of its parents don't exist, they will be created.\r\n *\r\n * @param {string} path - The path of the property to set, optionally with a JSON pointer in the hash\r\n * @param {*} value - The value to assign\r\n */\r\n$Refs.prototype.set = function (path, value) {\r\n  let absPath = url.resolve(this._root$Ref.path, path);\r\n  let withoutHash = url.stripHash(absPath);\r\n  let $ref = this._$refs[withoutHash];\r\n\r\n  if (!$ref) {\r\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\r\n  }\r\n\r\n  $ref.set(absPath, value);\r\n};\r\n\r\n/**\r\n * Creates a new {@link $Ref} object and adds it to this {@link $Refs} object.\r\n *\r\n * @param {string} path  - The file path or URL of the referenced file\r\n */\r\n$Refs.prototype._add = function (path) {\r\n  let withoutHash = url.stripHash(path);\r\n\r\n  let $ref = new $Ref();\r\n  $ref.path = withoutHash;\r\n  $ref.$refs = this;\r\n\r\n  this._$refs[withoutHash] = $ref;\r\n  this._root$Ref = this._root$Ref || $ref;\r\n\r\n  return $ref;\r\n};\r\n\r\n/**\r\n * Resolves the given JSON reference.\r\n *\r\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\r\n * @param {$RefParserOptions} [options]\r\n * @returns {Pointer}\r\n * @protected\r\n */\r\n$Refs.prototype._resolve = function (path, options) {\r\n  let absPath = url.resolve(this._root$Ref.path, path);\r\n  let withoutHash = url.stripHash(absPath);\r\n  let $ref = this._$refs[withoutHash];\r\n\r\n  if (!$ref) {\r\n    throw ono(`Error resolving $ref pointer \"${path}\". \\n\"${withoutHash}\" not found.`);\r\n  }\r\n\r\n  return $ref.resolve(absPath, options, path);\r\n};\r\n\r\n/**\r\n * Returns the specified {@link $Ref} object, or undefined.\r\n *\r\n * @param {string} path - The path being resolved, optionally with a JSON pointer in the hash\r\n * @returns {$Ref|undefined}\r\n * @protected\r\n */\r\n$Refs.prototype._get$Ref = function (path) {\r\n  path = url.resolve(this._root$Ref.path, path);\r\n  let withoutHash = url.stripHash(path);\r\n  return this._$refs[withoutHash];\r\n};\r\n\r\n/**\r\n * Returns the encoded and decoded paths keys of the given object.\r\n *\r\n * @param {object} $refs - The object whose keys are URL-encoded paths\r\n * @param {...string|string[]} [types] - Only return paths of the given types (\"file\", \"http\", etc.)\r\n * @returns {object[]}\r\n */\r\nfunction getPaths ($refs, types) {\r\n  let paths = Object.keys($refs);\r\n\r\n  // Filter the paths by type\r\n  types = Array.isArray(types[0]) ? types[0] : Array.prototype.slice.call(types);\r\n  if (types.length > 0 && types[0]) {\r\n    paths = paths.filter((key) => {\r\n      return types.indexOf($refs[key].pathType) !== -1;\r\n    });\r\n  }\r\n\r\n  // Decode local filesystem paths\r\n  return paths.map((path) => {\r\n    return {\r\n      encoded: path,\r\n      decoded: $refs[path].pathType === \"file\" ? url.toFileSystemPath(path, true) : path\r\n    };\r\n  });\r\n}\r\n"]},"metadata":{},"sourceType":"script"}